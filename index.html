<!DOCTYPE html>
<html>
  <head>
    <title>Solar System Simulation</title>
    <meta charset="us-ascii">
  </head>

  <body>
    <canvas id="canvas" width="640" height="480">
    </canvas>

    <script type="text/javascript">
      "use strict"

      function Body(name, radius) {
        this.name   = name
        this.radius = Math.log(radius) * 0.01
      }

      Body.prototype.draw = function(ctx, x, y) {
        ctx.beginPath()
        ctx.arc(x, y, this.radius, 0, 2 * Math.PI, true)
        ctx.fill()
      }

      function KeplerBody(name, radius, epoch, axis, eccentricity, inclination, argument, longitude, anomaly) {
        var ci = Math.cos(inclination),
            sw = Math.sin(argument),
            cw = Math.cos(argument),
            sl = Math.sin(longitude),
            cl = Math.cos(longitude)

        Body.call(this, name, radius)

        this.epoch        = epoch
        this.major        = axis
        this.minor        = axis * Math.sqrt(1 - eccentricity * eccentricity)
        this.eccentricity = eccentricity
        this.inclination  = inclination
        this.argument     = argument
        this.longitude    = longitude
        this.anomaly      = anomaly
        this.motion       = Math.pow(axis, -1.5) * 0.017202098948448492
        this.a            = cw * cl - sw * sl * ci
        this.b            = cw * sl + sw * cl * ci
        this.c            = sw * cl + cw * sl * ci
        this.d            = sw * sl - cw * cl * ci
      }

      KeplerBody.prototype.__proto__ = Body.prototype

      KeplerBody.prototype.draw = function(ctx, x, y, t) {
        var m  = this.anomaly + (t - this.epoch) * this.motion

        t = m
        t = m + this.eccentricity * Math.sin(t)
        t = m + this.eccentricity * Math.sin(t)
        t = m + this.eccentricity * Math.sin(t)

        var u = this.major * (Math.cos(t) - this.eccentricity),
            v = this.minor * Math.sin(t)

        Body.prototype.draw.call(
          this,
          ctx,
          x + this.a * u - this.c * v,
          y - this.b * u + this.d * v,
          this.radius
        )
      }

      function request(url, callback) {
        var req = new XMLHttpRequest()

        req.onreadystatechange = function() {
          if(req.readyState === 4)
            callback(
              req.status !== 0 && req.status !== 200 ?
                new Error("Received status " + req.status + " from server.") :
                undefined,
              req.responseText
            )
        }

        req.overrideMimeType("text/plain")
        req.open("GET", url)
        req.send()
      }

      function parse(data) {
        var rad   = Math.PI / 180,
            regex = /^([^,]*),([^,]*)(?:,([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*))?$/gm,
            array = [],
            match

          while(match = regex.exec(data))
            /* FIXME: This check is brittle. We should try parseFloat on each
             * argument. If we have all of them, build a KeplerBody. If we have
             * the name and the radius, build a Body. Otherwise, skip! */
            if(match[3] === undefined ||
               match[4] === undefined ||
               match[5] === undefined ||
               match[6] === undefined ||
               match[7] === undefined ||
               match[8] === undefined ||
               match[9] === undefined)
              array.push(new Body(
                match[1],
                parseFloat(match[2])
              ))

            else
              array.push(new KeplerBody(
                match[1],
                parseFloat(match[2]),
                parseFloat(match[3]),
                parseFloat(match[4]),
                parseFloat(match[5]),
                parseFloat(match[6]) * rad,
                parseFloat(match[7]) * rad,
                parseFloat(match[8]) * rad,
                parseFloat(match[9]) * rad
              ))

        return array
      }

      request("elements.csv", function(err, data) {
        if(err)
          throw err

        data = parse(data)

        var canvas = document.getElementById("canvas"),
            ctx    = canvas.getContext("2d"),
            start  = Date.now()

        setInterval(function() {
          /* FIXME: translation has been moved into the drawing function. Move
           * scaling in, too. */
          var x = ctx.canvas.width * 0.5 / 32,
              y = ctx.canvas.height * 0.5 / 32,
              t = 51544 + (Date.now() - start) * 0.001 * 365.25 / 12,
              i = data.length

          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
          ctx.save()
          ctx.scale(32, 32)
          while(i--)
            data[i].draw(ctx, x, y, t)
          ctx.restore()
        }, 0)
      })
    </script>
  </body>
</html>
